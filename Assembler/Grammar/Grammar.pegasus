@namespace Assembler.Grammar
@classname Parser

@using System.Globalization
@using Assembler.Grammar.AST
@using Assembler.Grammar.AST.Instructions
@using Assembler.Grammar.AST.Operands
@using DCPU16

primary <AsmFile> -memoize
    = l:line<0,,newline> _ EOF { new AsmFile(l.ToList()) }

line <Line>
    = l:label? _ i:instruction? _ (";" .*)? { new Line(l.SingleOrDefault(), i.SingleOrDefault()) }

label <string>
    = ":" l:identifier { l }

instruction <BaseInstruction>
    = o:basic_opcode _ b:operand_b _ "," _ a:operand_a { new BasicInstruction(o, a, b) }
    / o:special_opcode _ a:operand_a { new SpecialInstruction(o, a) }
    / "dat" _ n:number+ { new DatInstruction(n.ToList()) }

basic_opcode <BasicOpcode>
    = "SET"i { BasicOpcode.SET }
    / "ADD"i { BasicOpcode.ADD }
    / "SUB"i { BasicOpcode.SUB }
    / "MUL"i { BasicOpcode.MUL }
    / "MLI"i { BasicOpcode.MLI }
    / "DIV"i { BasicOpcode.DIV }
    / "DVI"i { BasicOpcode.DVI }
    / "MOD"i { BasicOpcode.MOD }
    / "MDI"i { BasicOpcode.MDI }
    / "AND"i { BasicOpcode.AND }
    / "BOR"i { BasicOpcode.BOR }
    / "XOR"i { BasicOpcode.XOR }
    / "SHR"i { BasicOpcode.SHR }
    / "ASR"i { BasicOpcode.ASR }
    / "SHL"i { BasicOpcode.SHL }
    / "IFB"i { BasicOpcode.IFB }
    / "IFC"i { BasicOpcode.IFC }
    / "IFE"i { BasicOpcode.IFE }
    / "IFN"i { BasicOpcode.IFN }
    / "IFG"i { BasicOpcode.IFG }
    / "IFA"i { BasicOpcode.IFA }
    / "IFL"i { BasicOpcode.IFL }
    / "IFU"i { BasicOpcode.IFU }
    / "ADX"i { BasicOpcode.ADX }
    / "SBX"i { BasicOpcode.SBX }
    / "STI"i { BasicOpcode.STI }
    / "STD"i { BasicOpcode.STD }

special_opcode <SpecialOpcode>
    = "JSR"i { SpecialOpcode.JSR }
    / "HCF"i { SpecialOpcode.HCF }
    / "INT"i { SpecialOpcode.INT }
    / "IAG"i { SpecialOpcode.IAG }
    / "IAS"i { SpecialOpcode.IAS }
    / "RFI"i { SpecialOpcode.RFI }
    / "IAQ"i { SpecialOpcode.IAQ }
    / "HWN"i { SpecialOpcode.HWN }
    / "HWQ"i { SpecialOpcode.HWQ }
    / "HWI"i { SpecialOpcode.HWI }

operand_a <BaseOperand>
    = s:small_number { new SmallLiteral(s) }
    / "POP"i { new PushPop(false) }
    / operand

operand_b <BaseOperand>
    = "PUSH"i { new PushPop(true) }
    / operand

operand <BaseOperand>
    = r:register { new RegisterValue(r) }
    / "[" _ r:register _ "]" { new IndirectRegister(r) }
    / n:number { new NextWordLiteral(n) }
    / "[" _ n:number _ "]" { new IndirectNextWord(n) }
    / "[" _ r:register _ "+" _ n:number  _"]" { new IndirectRegisterNextWord(r, n) }
    / i:identifier { new LabelValue(i) }
    / "[" _ i:identifier _ "]" { new IndirectLabel(i) }

register <Register>
    = "A" { Register.A }
    / "B" { Register.B }
    / "C" { Register.C }
    / "X" { Register.X }
    / "Y" { Register.Y }
    / "Z" { Register.Z }
    / "I" { Register.I }
    / "J" { Register.J }
    / "PC" { Register.PC }
    / "EX" { Register.EX }
    / "SP" { Register.SP }

small_number <int>
    = n:number &{n >= -1 && n <= 31} { n }

number <int>
    = hex_number
    / decimal_number

decimal_number <int>
    = s:("-"? [0-9]+) { int.Parse(s) }

hex_number <int>
    = s:("0" [xX] [0-9a-fA-F]+) { System.Convert.ToInt32(s, 16) }

identifier <string>
    = s:([a-zA-Z_][a-zA-Z0-9_]<0,>) { string.Join("", s) }

newline
    = "\r\n"
    / "\n"

_
    = [ \t]*

EOF
    = !.
    / unexpected:. #error{ "Unexpected character '" + unexpected + "'." }